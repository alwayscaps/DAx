;
; dax1.asm
;
; Created: 2/19/2018 8:52:32 PM
; Author : Kyle
;


LDI XH, 0x02	;SETTING THE HIGH BIT OF STARTADDS INTO X POINTER
OUT SPH, XH		;SETTING HIGH BIT OF STACK POINTER FROM X POINTER
LDI XL, 0x22	;SETTING LOW BIT OF STACK POINTER FROM X POINTER
OUT SPL, XL		;SETTING LOW BIT OF STACK POINTER FROM X POINTER

LDI YH, 0x04	;SETTING THE HIGH BIT OF STARTADDS INTO X POINTER
LDI YL, 0x00	;SETTING LOW BIT OF STACK POINTER FROM X POINTER

LDI ZH, 0x06	;SETTING THE HIGH BIT OF STARTADDS INTO X POINTER
LDI ZL, 0x00	;SETTING LOW BIT OF STACK POINTER FROM X POINTER



LDI XH, 0X00		; USE XH TO COUNT FROM 0 TO 300

START:
PUSH XH			; USE THE VALUE IN XH AS OUR STARTING VALUE FOR COUTNING
INC XH			;WE WILL INCREAMENT XH TO GET DIFFERENT VALUES  
CPI XH, 0XFF	; ONCE XH = 255 WE NEED TO START DECREMENT FOR THE REMAINDING NUMBERS
BREQ STARTDEC	;NOW WE ARE AT 255 LETS GRAB THE REMAINING 45 NUMBERS
JMP START		;WE HAVENT REACHED 255 YET, SO LETS KEEP PUSHING TO THE STACK

STARTDEC:
PUSH XH			;PUSH 255 ONTO STACK
DEC XH			;CHANGE VALUE TO 245
CPI XH, 0XD3	;CHECK TO MAKE SURE WE STOP AT THE 300 NUMBERS STORED
BREQ PART1DONE	;WE DONE WITH FILLING NUMBERS FAM
JMP STARTDEC	;WE STILL HAVE MORE NUMBERS TO GO, PUSH HARDER
PART1DONE:		;
PUSH XH			;PUSH LAST NUMBER ON STACK
LDI XH, 0x00	;CLEAR HIGH BITS OF X FOR LATER USE
LDI XL, 0x00


PART2:
LDI R16, 0X00	;CLEAR CHECK REGISTER
CPI XH, 0x02	;IF STACK HAS BEEN POP'D 300 TIMES MOVE TO STEP 4
BREQ ISDONE		;WE HAVE CHECKED TO SEE IF THE HIGH BITS MATCH THE HIGH BITS OF 0X0222
JMP RETURN		;WE ARE NOT DONE, KEEP POP' AND LOCK'N

ISDONE:
CPI XL, 0x22	;CHECKING LOW BITS TO MAKE SURE WE ARE AT 299
BREQ PART3		;WE DONE FAM, TIME TO ADD

RETURN:
POP R17			;GRAP VALUE OFF STACK
IN XH, SPH		;STORE CURRENT POSITION OF STACK INTO X
IN XL, SPL
MOV R16,R17		; COPY THE NUMBER WE POPPED INTO R16.

STARTDIVISION:
CPI R16, 0X00		;CHECK TO SEE IF CURRENT VALUE IS 0
BREQ DIV5			;IF 0 THEN CURRENT VALUE(CV) IS DIVISIBLE BY 5, WE DONE FAM
CPI R16, 0x04		;CHECK TO SEE IF CV IS 4
BREQ NOTDIV5		;4 IS NOT DIVISIBLE BY 5

CPI R16, 0x03		;CHECK TO SEE IF CV IS 3
BREQ NOTDIV5		;3 IS NOT DIVISIBLE BY 5

CPI R16, 0x02		;CHECK TO SEE IF CV IS 2
BREQ NOTDIV5		;2 IS NOT DIVISIBLE BY 5


CPI R16, 0x01		;CHECK TO SEE IF CV IS 1
BREQ NOTDIV5		;1 IS NOT DIVISIBLE BY 5

SUBI R16, 0x05		;CV IS GREATER THEN 5, DECREMENT CV BY 5
JMP STARTDIVISION	;REPEAT DIVSION PROCCESS

DIV5:
;HERE WE ARE DIVISBLE BY 5 AND NEED TO STORE THE VALUE INTO Y AT LOCATION X0600
OUT SPH, YH		;POINT STACKPOINTER AT Y MEMORY LOCATION, HIGH BIT COPIED
OUT SPL, YL		;LOW BIT COPIED
PUSH R17			;STORE THE VALUE OF CV IN Y BLOCK, BEGINNING WITH 0X0400
IN YH, SPH		;STORE CURRENT POSITION OF STACK INTO Y FOR RETURNING
IN YL, SPL
OUT SPH, XH		;PUT SP BACK TO NUMBER LIST IN ORDER TO GRAB NEXT NUMBER
OUT SPL, XL		
JMP PART2


NOTDIV5:
OUT SPH, ZH		;POINT STACKPOINTER AT Y MEMORY LOCATION, HIGH BIT COPIED
OUT SPL, ZL		;LOW BIT COPIED
PUSH R17			;STORE THE VALUE OF CV IN Y BLOCK, BEGINNING WITH 0X0400
IN ZH, SPH		;STORE CURRENT POSITION OF STACK INTO Z FOR RETURNING
IN ZL, SPL
OUT SPH, XH		;PUT SP BACK TO NUMBER LIST IN ORDER TO GRAB NEXT NUMBER
OUT SPL, XL		
JMP PART2




PART3:
;HERE WE WANT TO SET SP TO THE LAST VALUE IN THE 0x0600 BLOCK AND ADD IT TO THE Y REGISTER, COPY THAT VALUE TO R16/17
;THEN SET Y BACK TO THE LOCATION OF SP, SO THAT SP CAN BE MOVED TO REPEAT THE SAME LOGIC ON 0x0400 BLOCK
LDI R16, 0x00	;CLEARING R16.17
LDI R17,0x00	
LDI R18, 0X00
LDI R19, 0X00
LDI R22, 0X00

START3:
OUT SPH, YH		;POINT SP AT THE CURRRENT VALUE IN 0x0400 BLOCK
OUT SPL, YL		;
CPI YH, 0X04	;CHECK TO SEE IF WE ARE CLOSE TO FINISHING THE BLOCK	
BREQ ENDYSTACK	;SINCE YH=04 WE NEED TO MAKE SURE YL IS 00 FOR YH=0x0400
JMP GETNUMY		;BEGIN ADDING THE VALUES FROM Y BLOCK(DIV)

ENDYSTACK:		;
CPI YL, 0X00	;CHECK TO SEE IF WE ARE END OF Y BLOCK
BREQ SETYFLAG	;SINCE WE ARE SET FLAG SAYING Y IS FINISHED SO WE KNOW TO EXIT ZBLOCK
JMP GETNUMY		;WE ARE NOT DONE, KEEP POP'N

SETYFLAG:
LDI R22, 0X01
JMP GETZ

GETNUMY:
POP R21			;R21 HOLDS LATEST VALUE OF THE 0x0400
IN YH, SPH		; SAVE THE NEW STACK POINTER OF YH
IN YL, SPL		; SAVE THE NEW STACK POINTER OF YL
CPI R21, 0X00
BREQ GETZ
MOV XH, R17		; LOAD THE CURRENT SUM FROM Y INTO X
MOV XL, R16		; LOAD THE CURRENT SUM FROM Y INTO X
MOV R20, XL		; COPY THE XL VALUE INTO R20 SO WE CAN COMPARE FOR AN OVERFLOW
ADD XL, R21		; ADD THE NUMBER FROM THE STACK TO THE CURRENT SUM
CP XL, R20		; COMPARE THE XL VALUE INTO R20 SO WE CAN COMPARE FOR AN OVERFLOW
BRGE ADDOVERFLOW	; IF THE OVERFLOW OCCURRED THEN INCREMENT XH
JMP CONTINUE3		; SKIP THE OVERFLOW CHECK

ADDOVERFLOW:
INC XH			;INCREASE HIGH BIT TO COMPENSATE FOR OVERFLOW

CONTINUE3:	
MOV R17, XH		;STORING THE CURRENT SUM TOTAL OF Y BLOCK INTO X
MOV R16, XL		

GETZ:
OUT SPH, ZH		;POINT SP AT THE CURRRENT VALUE IN 0x0400 BLOCK
OUT SPL, ZL
CPI ZH, 0X06	;CHECKING TO SEE IF WE ARE CLOSE TO THE END OF ZBLOCK	
BREQ ENDZSTACK	;WE ARE CLOSE, LETS SEE IF LOW BIT IS 00 TO MAKE Z = 0x0600
JMP GETNUMZ

ENDZSTACK:
CPI ZL, 0X00	;MAKE SURE WE ARE AT THE END OF THE STACK
BREQ CHECKYFLAG	;THE 
JMP GETNUMZ		;ITS NOT OVER, KEEP PO

CHECKYFLAG:
CPI R22, 0X01	;IS Y BLOCK FINISHED?
BREQ DONE3		;YEAH WE GOOD FAM
JMP START3		;NOT FINISHED, KEEP POP'N

GETNUMZ:
POP R21			;R21 HOLDS LATEST VALUE OF THE 0x0400
IN ZH, SPH		; SAVE THE NEW STACK POINTER OF YH
IN ZL, SPL		; SAVE THE NEW STACK POINTER OF YL
CPI R21, 0X00
BREQ GETNUMY
MOV XH, R19		; LOAD THE CURRENT SUM FROM Y INTO X
MOV XL, R18		; LOAD THE CURRENT SUM FROM Y INTO X
MOV R20, XL		; COPY THE XL VALUE INTO R20 SO WE CAN COMPARE FOR AN OVERFLOW
ADD XL, R21		; ADD THE NUMBER FROM THE STACK TO THE CURRENT SUM
CP R20,XL		; COMPARE THE XL VALUE INTO R20 SO WE CAN COMPARE FOR AN OVERFLOW
BRGE ADDOVERFLOWZ	; IF THE OVERFLOW OCCURRED THEN INCREMENT XH
JMP CONTINUEZ		; SKIP THE OVERFLOW CHECK

ADDOVERFLOWZ:
INC XH				;OVERFLOWED, INCREMENT X

CONTINUEZ:		;STORING THE CURRENT TOTAL SUM		
MOV R19, XH		
MOV R18, XL		
JMP START3	;KEEP GRABBING BLOCK VALUES

DONE3:


